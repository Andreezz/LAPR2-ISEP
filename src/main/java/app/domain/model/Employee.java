package app.domain.model;

import app.domain.shared.Constants;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.math.NumberUtils;

import java.io.Serializable;
import java.util.Objects;
import java.util.regex.Pattern;

/**
 * Employee Class for the UserStory: Register an Employee
 * @author Lourenço Mayol -> 1211206@isep.ipp.pt
 */

public class Employee implements Serializable
{
    /** These attributes represent an employee
     */

    private static final long serialVersionUID = 3L;
    private String name;
    private String phoneNumber;
    private String id;
    private String email;
    private String cc;
    private String address;

    /** Creates an Employee with the specified information. If any attribute is null then an exception will be activated.
     * @param address represents the employee's address
     * @param name represents the employee's name
     * @param phoneNumber represents the employee's phone number
     * @param id represents the employee's id (generated by IdGenerator)
     * @param email represents the employee's email
     * @param cc represents the employee's citizen card number
     */

    public Employee(String address , String name, String phoneNumber, String id, String email, String cc) {
        if(ObjectUtils.allNotNull(address, name, phoneNumber, id, email, cc)) {
            this.address = address;
            this.name = name;
            this.phoneNumber = phoneNumber;
            this.id = id;
            this.cc = cc;
            this.email = email;
        }
        else
            throw new IllegalArgumentException("Employee cannot have null attributes!");
    }

    /** Gets the employee's address
     * @return a String representing the employee's address
     */
    public String getAddress() {return address;}

    /** Gets the employee's citizen card
     * @return a String representing the employee's civil id
     */
    public String getCc() {return cc;}

    /** Gets the employee's phone number
     * @return a String representing the employee's phone number
     */
    public String getPhoneNumber() {return phoneNumber;}

    /** Gets the employee's company identification number
     * @return a String representing the employee's company id
     */
    public String getId() {return id;}

    /** Gets the employee's name
     * @return a String representing the employee's name
     */
    public String getName() {return name;}

    /** Gets the employee's e-amail
     * @return a String representing the employee's e-mail
     */
    public String getEmail() {return email;}

    /**
     * @param phoneNumber represents the phone number to be checked
     * The phone number is valid if this follows these rules:
     * phone number must have 12 characters (inculding portuguese prefix)
     * all of the characters in the phone number must be digits
     * if the prefix is 351 and the indicative is 91, 93 or 96
     * @return true if the phone number is valid
     */
    public boolean checkPhoneNumberFormat (String phoneNumber){
        int numberDigits = phoneNumber.length();
        //check number of digits
        if (numberDigits != Constants.PHONE_NUMBER_DIGITS) {
            throw new IllegalArgumentException("Phonenumber must have 9 digits!");
        }
        //check String is a number
        else {
            if (!NumberUtils.isDigits(phoneNumber))
                throw new IllegalArgumentException("All the characters in the phone number must be digits! Symbols or letters are not valid!");
            else {
                String indicative = String.valueOf(phoneNumber.charAt(0)) + String.valueOf(phoneNumber.charAt(1));
                if (!((indicative.equals("93") || indicative.equals("91") || indicative.equals("96") || indicative.equals("95"))))
                    throw new IllegalArgumentException("Phone number indicative must be 91 or 93 or 95 or 96!");
            }
        }
        return true;
    }

    /**
     * @param email represents the email to be checked
     * the email is valid if this follows the correct format for e-mails. Its parts must be separated by dots and it must have an at sign.
     * @return true if the e-mail is valid otherwise, it will return false
     */
    public boolean checkEmailFormat(String email){
        String emailRegex = "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$";
        Pattern pat = Pattern.compile(emailRegex);
        return pat.matcher(email).matches();
    }

    /**
     * @param cc represents the cc to be checked
     * Considering that the cc is separated in 3 parts, it is valid if this follows these rules:
     * the cc must have 14 characters inculding the signs (-) that separate its parts
     * the first and second part must only contain digits
     * the 3 parts must be separated by - sign
     * the two first characters in the third part must be uppercase letters and the last character must be a digit
     * @return
     */
    public boolean checkCCFormat(String cc){
        String CCRegex = "^[0-9]{8}$";
        Pattern pattern = Pattern.compile(CCRegex);
        if(!pattern.matcher(cc).matches()){
            throw new IllegalArgumentException("cc must have 8 characters and can only contain digits!");
        }
        return true;
    }


    /**
     * @param name represents the name to be checked
     * the name is valid if it only contains letters (ç is not valid).
     * @return true if the name is valid
     */
    public boolean checkNameFormat(String name){
        String [] nameParts = name.split(" ");
        for (int i = 0; i < nameParts.length; i++)
        {
            if (!nameParts[i].matches("[a-zA-ZáàâãéèêíïóôõöúçñÁÀÂÃÉÈÍÏÓÔÕÖÚÇÑ'.-]+")) {
                throw new IllegalArgumentException("SNS user's name must contain only letters!");
            }
        }
        return true;
    }

    /**
     * @param o any object that can be compared to an employee
     * the method will consider that the objects are equal if they are exactly the same or if an attribute that they share is equal (for example if their name is the same)
     * @return true if the objects are equal, otherwise returns false.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Employee)) return false;
        Employee employee = (Employee) o;
        return name.equals(employee.name) || phoneNumber.equals(employee.phoneNumber) || id.equals(employee.id) || email.equals(employee.email) || cc.equals(employee.cc) || address.equals(employee.address);
    }

    /**
     * @return hash code that is associated to each employee attribute
     */
    @Override
    public int hashCode() {
        return Objects.hash(name, phoneNumber, id, email, cc, address);
    }

    /**
     * @return a String containing all the employee's information
     */
    @Override
    public String toString() {
        return "Employee{" + "\n" +
                        "address=" + address + "\n" +
                        "name=" + name +  "\n" +
                        "phoneNumber=" + phoneNumber + "\n" +
                        "id=" + id + "\n" +
                        "email=" + email + "\n" +
                        "cc=" + cc + "\n" +
                        '}';
    }
}
